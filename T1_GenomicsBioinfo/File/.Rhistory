dim(data_S)
mu <- 10e-8
mu <- 1e-8
mu
mu*10^8
setwd("~/Documents/Term_2/T1_GenomicsBioinfo/File")
abs(data_N[i,]-data_N[j,])
i<-1
abs(data_N[i,]-data_N[j,])
n <- nrow(data_N) # nr of samples (chromosomes)
pi_N <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_N <- pi_N + sum(abs(data_N[i,]-data_N[j,]))
}
}
pi_N <- pi_N / ((n*(n-1))/2)
pi_N
n <- nrow(data_S) # nr of samples (chromosomes)
pi_S <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_S <- pi_S + sum(abs(data_S[i,]-data_S[j,]))
}
}
pi_S <- pi_S / ((n*(n-1))/2)
## estimates of Ne from Tajima's estimator
Ne_N_pi <- pi_N / (4 * 1e-8 * len)
Ne_S_pi <- pi_S / (4 * 1e-8 * len)
### calculate nr of SNPs and then the estimator
freqs <- apply(X=data_N, MAR=2, FUN=sum)/nrow(data_N)
snps_N <- length(which(freqs>0 & freqs<1))
watt_N <- snps_N / sum(1/seq(1,n-1))
freqs <- apply(X=data_S, MAR=2, FUN=sum)/nrow(data_S)
snps_S <- length(which(freqs>0 & freqs<1))
watt_S <- snps_S / sum(1/seq(1,n-1))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- watt_N / (4 * 1e-8 * len)
Ne_S_watt <- watt_S / (4 * 1e-8 * len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
abs(data_N[i,]-data_N[j,])
data_N[i,]-data_N[j,]
sum(abs(data_N[i,]-data_N[j,]))
data_N[i,]
data_N[i,2]
View(data_N)
View(data_S)
# repeat the same procedure to calculate pi_S (Tajima's estimator of theta for the Northern population)
n <- nrow(data_S)
pi_S <- 0
for (i in 1:n-1) { # loop of i
for (j in i+1:n) {
pi_S <- pi_S +sum(abs(data_S[i,]-data_S[j,]))
}
}
# divide by the nr of comparisons done
pi_S <- pi_S / ((n*(n-1))/2)
len
mu <- 1e-8
## now that you have theta you can estimate Ne using equation 14 on the slides
# remember to multiple the mutation rate 1e-8 with the length your sequence before plugging it into the quation
Ne_N_pi <- pi_N / (4*mu*len)
Ne_S_pi <- pi_S / (4*mu*len)
Ne_S_pi
Ne_N_pi
len
pi_N
mu <- 1e-8
## Practical on coalescence theory
## first thing, read genomic data for each population
## since the alleles are encoded as 0 and 1 in this case, it's better to store the data as a matrix
# set the length of the region
len <- 50000
# read data
data_N <- as.matrix(read.csv("../Data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_N)
data_S <- as.matrix(read.csv("../Data/killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_S)
## 1) We wish to estimate of effective population size
### I suggest to use the Tajima's estimator for theta as seen in class (equation 15): this is a relationship between theta (see equation 14, an estimator of genetic diversity) and Ne (population size) and mu (mutation rate)
# therefore you need to write a script that calculates the average number of pairwise differences (or Pi, equation 15).
# start from one population (e.g. North)
n <- nrow(data_N) # nr of samples (chromosomes)
pi_N <- 0 # # initialise pi
# the easiet thing will be to loop over all pairs of sequences (you need two nested for loops)
# for instance, if you have 4 sequences, how can you loop over these unique pairs:
# 1 vs 2
# 1 vs 3
# 1 vs 4
# 2 vs 3
# 2 vs 4
# 3 vs 4.
# You have two indexes for the loop. The first index (let's call it i) goes from 1 to 3 (while you have 4 sequences), and the second index (let's call it j) starts from 2 when i=1, starts from 3 when i=2, etc etc, and finished at 4.
# How can you create these two nested loops?
for (i in 1:n-1) { # loop of i
for (j in i+1:n) {
pi_N <- pi_N +sum(abs(data_N[i,]-data_N[j,]))
}
}
# divide by the nr of comparisons done
pi_N <- pi_N / ((n*(n-1))/2)
# you obtained a Tajima's estimator of theta for the Northern population
# repeat the same procedure to calculate pi_S (Tajima's estimator of theta for the Northern population)
n <- nrow(data_S)
pi_S <- 0
for (i in 1:n-1) { # loop of i
for (j in i+1:n) {
pi_S <- pi_S +sum(abs(data_S[i,]-data_S[j,]))
}
}
# divide by the nr of comparisons done
pi_S <- pi_S / ((n*(n-1))/2)
## now that you have theta you can estimate Ne using equation 14 on the slides
# remember to multiple the mutation rate 1e-8 with the length your sequence before plugging it into the quation
Ne_N_pi <- pi_N / (4*mu*len)
Ne_S_pi <- pi_S / (4*mu*len)
Ne_N_pi
Ne_S_pi
len <- 50000
data_N <- as.matrix(read.csv("../Data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_N)
data_S <- as.matrix(read.csv("../Data/killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_S)
## 1) estimates of effective population size
### Tajima's estimator
n <- nrow(data_N) # nr of samples (chromosomes)
pi_N <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_N <- pi_N + sum(abs(data_N[i,]-data_N[j,]))
}
}
pi_N <- pi_N / ((n*(n-1))/2)
n <- nrow(data_S) # nr of samples (chromosomes)
pi_S <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_S <- pi_S + sum(abs(data_S[i,]-data_S[j,]))
}
}
pi_S <- pi_S / ((n*(n-1))/2)
## estimates of Ne from Tajima's estimator
Ne_N_pi <- pi_N / (4 * 1e-8 * len)
Ne_S_pi <- pi_S / (4 * 1e-8 * len)
### Watterson's estimator
### calculate nr of SNPs and then the estimator
freqs <- apply(X=data_N, MAR=2, FUN=sum)/nrow(data_N)
snps_N <- length(which(freqs>0 & freqs<1))
watt_N <- snps_N / sum(1/seq(1,n-1))
freqs <- apply(X=data_S, MAR=2, FUN=sum)/nrow(data_S)
snps_S <- length(which(freqs>0 & freqs<1))
watt_S <- snps_S / sum(1/seq(1,n-1))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- watt_N / (4 * 1e-8 * len)
Ne_S_watt <- watt_S / (4 * 1e-8 * len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
Ne_N_pi
Ne_S_pi
pi_N
pi_S
mu
mu == 1e-8
Ne_N_pi
Ne_S_pi
source('~/Documents/Term_2/T1_GenomicsBioinfo/File/4_code_structure_practical.R')
len <- 50000
# read data
data_N <- as.matrix(read.csv("../Data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_N)
data_S <- as.matrix(read.csv("../Data/killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_S)
n <- nrow(data_N) # nr of samples (chromosomes)
pi_N <- 0 # # initialise pi
# the easiet thing will be to loop over all pairs of sequences (you need two nested for loops)
# for instance, if you have 4 sequences, how can you loop over these unique pairs:
# 1 vs 2
# 1 vs 3
# 1 vs 4
# 2 vs 3
# 2 vs 4
# 3 vs 4.
# You have two indexes for the loop. The first index (let's call it i) goes from 1 to 3 (while you have 4 sequences), and the second index (let's call it j) starts from 2 when i=1, starts from 3 when i=2, etc etc, and finished at 4.
# How can you create these two nested loops?
for (i in 1:(n-1)) { # loop of i
for (j in (i+1):n) {
pi_N <- pi_N +sum(abs(data_N[i,]-data_N[j,]))
}
}
# divide by the nr of comparisons done
pi_N <- pi_N / ((n*(n-1))/2)
# you obtained a Tajima's estimator of theta for the Northern population
# repeat the same procedure to calculate pi_S (Tajima's estimator of theta for the Northern population)
n <- nrow(data_S)
pi_S <- 0
for (i in 1:n-1) { # loop of i
for (j in i+1:n) {
pi_S <- pi_S +sum(abs(data_S[i,]-data_S[j,]))
}
}
# divide by the nr of comparisons done
pi_S <- pi_S / ((n*(n-1))/2)
## now that you have theta you can estimate Ne using equation 14 on the slides
# remember to multiple the mutation rate 1e-8 with the length your sequence before plugging it into the quation
Ne_N_pi <- pi_N / (4*mu*len) # 460.5263
Ne_S_pi <- pi_S / (4*mu*len) # 47.36842
Ne_N_pi
Ne_S_pi
len <- 50000
data_N <- as.matrix(read.csv("../Data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_N)
data_S <- as.matrix(read.csv("../Data/killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data_S)
n <- nrow(data_N) # nr of samples (chromosomes)
pi_N <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_N <- pi_N + sum(abs(data_N[i,]-data_N[j,]))
}
}
pi_N <- pi_N / ((n*(n-1))/2)
n <- nrow(data_S) # nr of samples (chromosomes)
pi_S <- 0
for (i in 1:(n-1)) {
for (j in (i+1):n) {
pi_S <- pi_S + sum(abs(data_S[i,]-data_S[j,]))
}
}
pi_S <- pi_S / ((n*(n-1))/2)
## estimates of Ne from Tajima's estimator
Ne_N_pi <- pi_N / (4 * 1e-8 * len)
Ne_S_pi <- pi_S / (4 * 1e-8 * len)
Ne_N_pi
Ne_S_pi
# repeat the same procedure to calculate pi_S (Tajima's estimator of theta for the Northern population)
n <- nrow(data_S)
pi_S <- 0
for (i in 1:(n-1)) { # loop of i
for (j in (i+1):n) {
pi_S <- pi_S +sum(abs(data_S[i,]-data_S[j,]))
}
}
# divide by the nr of comparisons done
pi_S <- pi_S / ((n*(n-1))/2)
## now that you have theta you can estimate Ne using equation 14 on the slides
# remember to multiple the mutation rate 1e-8 with the length your sequence before plugging it into the quation
Ne_N_pi <- pi_N / (4*mu*len) # 4634.211
Ne_S_pi <- pi_S / (4*mu*len) # 47.36842
Ne_S_pi
### calculate nr of SNPs and then the estimator
freqs <- apply(X=data_N, MAR=2, FUN=sum)/nrow(data_N)
snps_N <- length(which(freqs>0 & freqs<1))
watt_N <- snps_N / sum(1/seq(1,n-1))
freqs
unique(freqs)
apply(X=data_N, MAR=2, FUN=sum)
?aapply(array, margin, ...)
?apply
length(which(freqs>0 & freqs<1))
S_N <- length(which(freqs>0 & freqs<1))
S_N
# repeat the same procedure for S population
freqs_S <- apply(data_S, 2, sum)
S_S <- length(which(freqs_S>0 & freqs_S<1))
watt_S <- S_S/ sum(1/seq(1:n-1))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- (4*mu*len)
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- S_N/(4*mu*len)
Ne_S_watt <- S_S/(4*mu*len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
freqs <- apply(X=data_N, MAR=2, FUN=sum)/nrow(data_N)
snps_N <- length(which(freqs>0 & freqs<1))
watt_N <- snps_N / sum(1/seq(1,n-1))
freqs <- apply(X=data_S, MAR=2, FUN=sum)/nrow(data_S)
snps_S <- length(which(freqs>0 & freqs<1))
watt_S <- snps_S / sum(1/seq(1,n-1))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- watt_N / (4 * 1e-8 * len)
Ne_S_watt <- watt_S / (4 * 1e-8 * len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
# use equation 20 calculate watterson estimator
watt_N <- S_N / sum(1/seq(1,(n-1)))
# repeat the same procedure for S population
freqs_S <- apply(data_S, 2, sum)
S_S <- length(which(freqs_S>0 & freqs_S<1))
watt_S <- S_S/ sum(1/seq(1:(n-1)))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- S_N/(4*mu*len)
Ne_S_watt <- S_S/(4*mu*len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
# repeat the same procedure for S population
freqs_S <- apply(data_S, 2, sum) / nrow(data_S)
S_S <- length(which(freqs_S>0 & freqs_S<1))
watt_S <- S_S / sum(1/seq(1:(n-1)))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- S_N/(4*mu*len)
Ne_S_watt <- S_S/(4*mu*len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
freqs <- apply(X=data_N, MAR=2, FUN=sum)/nrow(data_N)
snps_N <- length(which(freqs>0 & freqs<1))
watt_N <- snps_N / sum(1/seq(1,n-1))
freqs <- apply(X=data_S, MAR=2, FUN=sum)/nrow(data_S)
snps_S <- length(which(freqs>0 & freqs<1))
watt_S <- snps_S / sum(1/seq(1,n-1))
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- watt_N / (4 * 1e-8 * len)
Ne_S_watt <- watt_S / (4 * 1e-8 * len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
### estimates of Ne from Wattersons' estimator
Ne_N_watt <- watt_N/(4*mu*len)
Ne_S_watt <- watt_S/(4*mu*len)
cat("\nThe North population has estimates of effective population size of", Ne_N_pi, "and", Ne_N_watt)
cat("\nThe South population has estimates of effective population size of", Ne_S_pi, "and", Ne_S_watt)
### North population
sfs_N <- rep(0, n-1) # initialise a vector from 0 to n-1
sfs_N
n
### calculate allele frequencies using the apply functions as previously shown
derived_freqs <- apply(data_N, 2, sum)
freq <- derived_freqs / n
freq
derived_freqs
### calculate allele frequencies using the apply functions as previously shown
derived_freqs <- apply(data_N, 2, sum) / n
unique(derived_freqs)
length(derived_freqs)
length(unique(derived_freqs))
### North population
sfs_N <- rep(0, n-1) # initialise a vector from 0 to n-1
### calculate allele frequencies using the apply functions as previously shown
derived_freqs <- apply(data_N, 2, sum) / n
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences of each possible allele frequency
for (i in 1:length(unique(derived_freqs))) sfs_N[i] <- length(which(derived_freqs == derived_freqs[i]))
### South population
# repeat as above
sfs_S <- rep(0, n-1)
derived_freqs <- apply(data_S, 2, sum) / n
for (i in 1:length(unique(derived_freqs))) sfs_S[i] <- length(which(derived_freqs == derived_freqs[i]))
### plot
barplot(sfs_N) # or use any other plotting functions
barplot(sfs_S)
### North population
sfs_N <- rep(0, n-1)
### allele frequencies
derived_freqs <- apply(X=data_N, MAR=2, FUN=sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences
for (i in 1:length(sfs_N)) sfs_N[i] <- length(which(derived_freqs==i))
### South population
sfs_S <- rep(0, n-1)
### allele frequencies
derived_freqs <- apply(X=data_S, MAR=2, FUN=sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences
for (i in 1:length(sfs_S)) sfs_S[i] <- length(which(derived_freqs==i))
### plot
barplot(t(cbind(sfs_N, sfs_S)), beside=T, names.arg=seq(1,nrow(data_S)-1,1), legend=c("North", "South"))
cat("\nThe population with the greater population size has a higher proportion of singletons, as expected.")
sfs <- matrix(0, nrow=nrow(data_N)+1, ncol=nrow(data_S)+1)
for (i in 1:ncol(data_N)) {
freq_N <- sum(data_N[,i])
freq_S <- sum(data_S[,i])
sfs[freq_N+1,freq_S+1] <- sfs[freq_N+1,freq_S+1] + 1
}
sfs[1,1] <- NA # ignore non-SNPs
image(t(sfs))
### North population
f_N <- rep(0, n-1) # initialise a vector from 0 to n-1
### calculate allele frequencies using the apply functions as previously shown
derived_freqs <- apply(data_N, 2, sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences of each possible allele frequency
for (i in 1:n-1) f_N[i] <- length(which(derived_freqs == i))
### North population
f_N <- rep(0, n-1) # initialise a vector from 0 to n-1
### calculate allele frequencies using the apply functions as previously shown
derived_freqs <- apply(data_N, 2, sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences of each possible allele frequency
for (i in 1:(n-1)) f_N[i] <- length(which(derived_freqs == i))
### South population
# repeat as above
f_S <- rep(0, n-1)
derived_freqs <- apply(data_S, 2, sum)
for (i in 1:(n-1)) f_S[i] <- length(which(derived_freqs == derived_freqs[i]))
### plot
barplot(sfs_N) # or use any other plotting functions
barplot(sfs_S)
### plot
barplot(t(cbind(sfs_N, sfs_S)), beside=T, names.arg=seq(1,nrow(data_S)-1,1), legend=c("North", "South"))
### North population
sfs_N <- rep(0, n-1)
### allele frequencies
derived_freqs <- apply(X=data_N, MAR=2, FUN=sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences
for (i in 1:length(sfs_N)) sfs_N[i] <- length(which(derived_freqs==i))
### South population
sfs_S <- rep(0, n-1)
### allele frequencies
derived_freqs <- apply(X=data_S, MAR=2, FUN=sum)
### the easiest (but slowest) thing to do would be to loop over all possible allele frequencies and count the occurrences
for (i in 1:length(sfs_S)) sfs_S[i] <- length(which(derived_freqs==i))
### plot
barplot(t(cbind(sfs_N, sfs_S)), beside=T, names.arg=seq(1,nrow(data_S)-1,1), legend=c("North", "South"))
cat("\nThe population with the greater population size has a higher proportion of singletons, as expected.")
### plot
barplot(t(cbind(f_N, f_S)))# or use any other plotting functions
### plot
barplot(f_N)
barplot(t(cbind(f_N, f_S)), beside=T)# or use any other plotting functions
barplot(f_S)
f_S
f_N
### South population
# repeat as above
f_S <- rep(0, n-1)
derived_freqs <- apply(data_S, 2, sum)
for (i in 1:(n-1)) f_S[i] <- length(which(derived_freqs == i))
### plot
barplot(f_N)
barplot(f_S)
barplot(t(cbind(f_N, f_S)), beside=T)# or use any other plotting functions
f_S <- f_S/sum(f_S)
barplot(f_S)
f_N <- f_N/sum(f_N)
barplot(t(cbind(f_N, f_S)), beside=T)
sfs <- matrix(0, nrow=nrow(data_N)+1, ncol=nrow(data_S)+1)
for (i in 1:ncol(data_N)) {
freq_N <- sum(data_N[,i])
freq_S <- sum(data_S[,i])
sfs[freq_N+1,freq_S+1] <- sfs[freq_N+1,freq_S+1] + 1
}
sfs[1,1] <- NA # ignore non-SNPs
image(t(sfs))
### read data
len <- 2000
data <- as.matrix(read.csv("../Data/turtle.genotypes.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data)
### assign an name for each location
locations <- rep(c("A","B","C","D"), each=10)
### read data
len <- 2000
data <- as.matrix(read.csv("../Data/turtle.genotypes.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
dim(data)
### assign an name for each location
locations <- rep(c("A","B","C","D"), each=10)
View(data)
distance <- dist(data)
distance
tree <- hclust(distance)
View(tree)
plot(tree, labels=locations)
### or we can do a PCA
### we can filter our low-frequency variants first
colors <- rep(c("blue","red","yellow","green"), each=10)
index <- which(apply(FUN=sum, X=data, MAR=2)/(nrow(data)*2)>0.05)
pca <- prcomp(data[,index], center=T, scale=T)
summary(pca)
plot(pca$x[,1], pca$x[,2], col=colors, pch=1)
legend("right", legend=sort(unique(locations)), col=unique(colors), pch=1)
data2 <- as.matrix(read.csv("../turtle.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
calcFST <- function(pop1, pop2) {
# only for equal sample sizes!
fA1 <- as.numeric(apply(FUN=sum, X=pop1, MAR=2)/nrow(pop1))
fA2 <- as.numeric(apply(FUN=sum, X=pop2, MAR=2)/nrow(pop2))
FST <- rep(NA, length(fA1))
for (i in 1:length(FST)) {
HT <- 2 * ( (fA1[i] + fA2[i]) / 2 ) * (1 - ((fA1[i] + fA2[i]) / 2) )
HS <- fA1[i] * (1 - fA1[i]) + fA2[i] * (1 - fA2[i])
FST[i] <- (HT - HS) / HT
}
FST
}
snps <- which(apply(FUN=sum, X=data2, MAR=2)/(nrow(data2))>0.05)
data2 <- as.matrix(read.csv("../Data/turtle.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
calcFST <- function(pop1, pop2) {
# only for equal sample sizes!
fA1 <- as.numeric(apply(FUN=sum, X=pop1, MAR=2)/nrow(pop1))
fA2 <- as.numeric(apply(FUN=sum, X=pop2, MAR=2)/nrow(pop2))
FST <- rep(NA, length(fA1))
for (i in 1:length(FST)) {
HT <- 2 * ( (fA1[i] + fA2[i]) / 2 ) * (1 - ((fA1[i] + fA2[i]) / 2) )
HS <- fA1[i] * (1 - fA1[i]) + fA2[i] * (1 - fA2[i])
FST[i] <- (HT - HS) / HT
}
FST
}
snps <- which(apply(FUN=sum, X=data2, MAR=2)/(nrow(data2))>0.05)
cat("\nFST value (average):",
"\nA vs B", mean(calcFST(data2[1:20,snps], data2[21:40,snps]), na.rm=T),
"\nA vs C", mean(calcFST(data2[1:20,snps], data2[41:60,snps]), na.rm=T),
"\nA vs D", mean(calcFST(data2[1:20,snps], data2[61:80,snps]), na.rm=T),
"\nB vs C", mean(calcFST(data2[21:40,snps], data2[41:60,snps]), na.rm=T),
"\nB vs D", mean(calcFST(data2[21:40,snps], data2[61:80,snps]), na.rm=T),
"\nC vs D", mean(calcFST(data2[41:60,snps], data2[61:80,snps]), na.rm=T),"\n")
## 2) there is no evidence for isolation by distance, but instead of admixture
locations
?dist
x <- matrix(rnorm(100), nrow = 5)
dist(x)
dist(x, diag = TRUE)
dist(x, upper = TRUE)
m <- as.matrix(dist(x))
d <- as.dist(m)
stopifnot(d == dist(x)
)
m
d
?prcomp
